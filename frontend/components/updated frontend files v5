Absolutely. Below are the **corrected versions** of both files with proper ABI import and usage. Once you've added the updated ABI or contract, we can continue debugging or expanding.

---

## ‚úÖ `WebAccessSBT.js` (User Component)

```js
'use client'

import { useEffect, useState } from 'react'
import {
  useAccount,
  useChainId,
  useSimulateContract,
  useWriteContract,
  useWaitForTransactionReceipt,
} from 'wagmi'
import { polygonAmoy } from 'wagmi/chains'
import { toast } from 'react-hot-toast'
import { readContract } from '@wagmi/core'
import WebAccessSBTV5_ABI from '../abis/WebAccessSBTV5_ABI.json'

const CONTRACT = '0x576c2c7544c180De7EBCa37d25c6c08Db543bBBF'

const options = [
  {
    id: 1n,
    label: '1 ‚Äì Coffee Voucher (Berlin)',
    desc: 'Redeem this SBT at a participating Berlin caf√© for a free drink. Soulbound and non-transferable.',
  },
  {
    id: 2n,
    label: '2 ‚Äì Restaurant Club (Copenhagen)',
    desc: 'Join our partner restaurant club and receive exclusive member deals. Permanent wallet membership.',
  },
  {
    id: 3n,
    label: '3 ‚Äì Free Meeting Pass',
    desc: 'Access a shared meeting space once with this one-time SBT. Ideal for remote professionals and freelancers.',
  },
  {
    id: 4n,
    label: '4 ‚Äì Business Meeting w/ NDA',
    desc: 'This token represents agreement to a confidential business meeting NDA. Legal doc is attached to the metadata.',
  },
]

export default function WebAccessSBT () {
  const { address, isConnected } = useAccount()
  const chainId = useChainId()
  const [typeId, setTypeId] = useState(1n)
  const [hash, setHash] = useState(null)
  const [tokens, setTokens] = useState([])

  const currentOption = options.find(o => o.id === typeId)

  useEffect(() => {
    async function fetchTokens () {
      if (!isConnected) return setTokens([])
      try {
        const owned = await readContract({
          address: CONTRACT,
          abi: WebAccessSBTV5_ABI.abi,
          functionName: 'tokensOfOwner',
          args: [address],
        })
        setTokens(owned.map(t => BigInt(t).toString()))
      } catch (err) {
        console.error('Failed to fetch tokens:', err)
        setTokens([])
      }
    }
    fetchTokens()
  }, [address, isConnected, hash])

  const {
    data: sim,
    error: simError,
    status: simStatus,
  } = useSimulateContract({
    address: CONTRACT,
    abi: WebAccessSBTV5_ABI.abi,
    functionName: 'claim',
    args: [typeId],
    account: address,
    query: { enabled: isConnected },
  })

  const { writeContractAsync, isPending: isSending } = useWriteContract({ mode: 'prepared' })

  const { isLoading: isMining, isSuccess: isConfirmed } = useWaitForTransactionReceipt({ hash })

  async function handleClaim () {
    try {
      if (!isConnected) return toast.error('Connect wallet first')
      if (chainId !== polygonAmoy.id)
        return toast.error('Switch to Polygon Amoy testnet')
      if (simError)
        return toast.error(simError.shortMessage || simError.message)
      if (!sim?.request)
        return toast.error('Simulation still pending‚Ä¶')

      const txHash = await writeContractAsync(sim.request)
      toast.success('Transaction sent ‚Äì waiting for confirmation‚Ä¶')
      setHash(txHash)
    } catch (err) {
      toast.error(err?.message ?? 'Transaction failed')
      console.error(err)
    }
  }

  const isDisabled = isSending || isMining || !!simError || simStatus === 'pending'

  return (
    <section className="w-full max-w-xl mx-auto mt-12 px-4 sm:px-6 lg:px-8">
      <div className="bg-white p-8 rounded-3xl shadow-xl border border-gray-200 space-y-8">
        <div>
          <h2 className="text-3xl font-extrabold text-blue-900 mb-2">üéâ Join the Network</h2>
          <p className="text-gray-700 leading-relaxed text-sm">
            Claim your Soulbound Token (SBT) to unlock perks ‚Äî from loyalty rewards to verified meeting access.
          </p>
        </div>

        <div className="space-y-4">
          <div>
            <label htmlFor="typeId" className="block text-sm font-semibold text-gray-900 mb-1">
              Choose a token type:
            </label>
            <select
              id="typeId"
              className="w-full rounded-md border border-gray-300 p-2 text-gray-800 bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={typeId.toString()}
              onChange={(e) => setTypeId(BigInt(e.target.value))}
            >
              {options.map(o => (
                <option key={o.id} value={o.id.toString()}>
                  {o.label}
                </option>
              ))}
            </select>
            {currentOption?.desc && (
              <p className="text-xs text-gray-600 italic mt-1">{currentOption.desc}</p>
            )}
          </div>

          {simError && (
            <div className="rounded bg-red-100 border border-red-300 p-3 text-sm text-red-800">
              ‚ö†Ô∏è {simError.shortMessage || simError.message}
            </div>
          )}

          <button
            onClick={handleClaim}
            disabled={isDisabled}
            className={`w-full rounded-xl py-3 font-semibold text-white transition
              ${isConfirmed ? 'bg-green-600'
                : (isSending || isMining) ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-blue-600 hover:bg-blue-700'}
            `}
          >
            {isConfirmed ? '‚úÖ Claimed'
              : isMining ? 'Confirming‚Ä¶'
                : isSending ? 'Sending‚Ä¶'
                  : simStatus === 'pending' ? 'Simulating‚Ä¶'
                    : 'Claim SBT'}
          </button>

          {hash && !isConfirmed && (
            <p className="text-xs text-center text-gray-500 break-words">Tx Hash: {hash}</p>
          )}

          {isConfirmed && (
            <p className="text-center text-green-700 text-sm mt-1 font-semibold">
              üéâ Success! Token minted to your wallet.
            </p>
          )}
        </div>

        {tokens.length > 0 && (
          <div className="bg-gray-50 border border-gray-200 rounded-xl p-4 mt-4">
            <h3 className="text-sm font-semibold text-gray-800 mb-2">üé´ Your Claimed Tokens</h3>
            <ul className="text-xs text-gray-700 space-y-1">
              {tokens.map(tokenId => (
                <li key={tokenId}>Token ID: {tokenId}</li>
              ))}
            </ul>
          </div>
        )}

        <div className="bg-blue-50 p-4 rounded-xl border border-blue-200 shadow-inner">
          <h3 className="text-base font-semibold text-blue-800 mb-2">‚ÑπÔ∏è About This System</h3>
          <p className="text-sm text-gray-700 leading-relaxed">
            The TEA Project enables loyalty networks and social membership clubs using on‚Äëchain proof of access.
            Soulbound Tokens (SBTs) can represent vouchers, discounts, verified event access, or meeting agreements with legal context.
            <br /><br />
            Everything is wallet-based and compatible with real-world businesses using QR codes or point-of-sale integrations.
          </p>
        </div>
      </div>
    </section>
  )
}
```

---

## ‚úÖ `AdminSBTManager.js` (Admin Component)

```js
'use client'

import { useState } from 'react'
import { useAccount, useWriteContract } from 'wagmi'
import WebAccessSBTV5_ABI from '../abis/WebAccessSBTV5_ABI.json'
import { toast } from 'react-hot-toast'

const CONTRACT_ADDRESS = '0x576c2c7544c180De7EBCa37d25c6c08Db543bBBF'

const predefinedTypes = [
  { id: 1n, label: '1 ‚Äì Coffee Vouchers', uri: 'https://example.com/metadata/1.json' },
  { id: 2n, label: '2 ‚Äì Restaurants Clubs', uri: 'https://example.com/metadata/2.json' },
  { id: 3n, label: '3 ‚Äì Free Individual Pass', uri: 'https://example.com/metadata/3.json' },
  { id: 4n, label: '4 ‚Äì Business Meetings NDA', uri: 'https://example.com/metadata/4.json' },
]

export default function AdminSBTManager () {
  const { address } = useAccount()
  const [typeId, setTypeId] = useState(predefinedTypes[0].id)
  const [uri, setUri] = useState(predefinedTypes[0].uri)
  const [burnable, setBurnable] = useState(false)
  const [maxSupply, setMaxSupply] = useState(100)
  const [useWhitelist, setUseWhitelist] = useState(false)
  const [organizer, setOrganizer] = useState('')
  const [airdropAddress, setAirdropAddress] = useState('')
  const [whitelistAddress, setWhitelistAddress] = useState('')

  const isAdmin = address?.toLowerCase() === process.env.NEXT_PUBLIC_ADMIN?.toLowerCase()
  const { writeContract } = useWriteContract()

  const exec = (fn, args, msg) => writeContract({
    address: CONTRACT_ADDRESS,
    abi: WebAccessSBTV5_ABI.abi,
    functionName: fn,
    args,
    onSuccess: () => toast.success(`‚úÖ ${msg}`),
    onError: (err) => toast.error(err.message),
  })

  if (!isAdmin) {
    return <div className="p-4 text-center text-red-600 font-semibold">Admin access required</div>
  }

  return (
    <div className="p-6 max-w-2xl mx-auto bg-white border rounded-xl space-y-6">
      <h2 className="text-2xl font-bold">üîß Admin: SBT Type Manager</h2>

      <select value={typeId.toString()} onChange={e => {
        const t = predefinedTypes.find(t => t.id.toString() === e.target.value)
        if (t) {
          setTypeId(t.id)
          setUri(t.uri)
        }
      }} className="w-full p-2 border rounded">
        {predefinedTypes.map(t => (
          <option key={t.id.toString()} value={t.id.toString()}>{t.label}</option>
        ))}
      </select>

      <input type="text" value={uri} onChange={e => setUri(e.target.value)} className="w-full p-2 border rounded" placeholder="Metadata URI" />

      <div className="flex items-center space-x-4">
        <label><input type="checkbox" checked={burnable} onChange={e => setBurnable(e.target.checked)} className="mr-2" />Burnable</label>
        <label><input type="checkbox" checked={useWhitelist} onChange={e => setUseWhitelist(e.target.checked)} className="mr-2" />Whitelist</label>
      </div>

      <input type="number" min={1} value={maxSupply} onChange={e => setMaxSupply(parseInt(e.target.value))} className="w-full p-2 border rounded" placeholder="Max Supply" />

      <div className="flex flex-wrap gap-2">
        <button onClick={() => exec('createSBTType', [typeId, uri, burnable, BigInt(maxSupply), useWhitelist], 'Created Type')} className="bg-blue-600 text-white px-4 py-2 rounded">Create</button>
        <button onClick={() => exec('setActive', [typeId, true], 'Activated')} className="bg-green-600 text-white px-4 py-2 rounded">Activate</button>
        <button onClick={() => exec('setActive', [typeId, false], 'Deactivated')} className="bg-yellow-600 text-white px-4 py-2 rounded">Deactivate</button>
      </div>

      <h3 className="text-lg font-bold mt-4">üë§ Organizer Management</h3>
      <input type="text" value={organizer} onChange={e => setOrganizer(e.target.value)} className="w-full p-2 border rounded" placeholder="0x... Organizer" />
      <button onClick={() => exec('setOrganizer', [typeId, organizer], 'Organizer Set')} className="mt-2 bg-indigo-600 text-white px-4 py-2 rounded">Set Organizer</button>

      <h3 className="text-lg font-bold mt-4">‚úâÔ∏è Whitelist Management</h3>
      <input type="text" value={whitelistAddress} onChange={e => setWhitelistAddress(e.target.value)} className="w-full p-2 border rounded" placeholder="0x... whitelist address" />
      <button onClick={() => exec('addToWhitelist', [typeId, [whitelistAddress]], 'Added to Whitelist')} className="mt-2 bg-purple-600 text-white px-4 py-2 rounded">Add to Whitelist</button>

      <h3 className="text-lg font-bold mt-4">üì§ Airdrop</h3>
      <input type="text" value={airdropAddress} onChange={e => setAirdropAddress(e.target.value)} className="w-full p-2 border rounded" placeholder="0x... recipient address" />
      <button onClick={() => exec('airdropTo', [typeId, [airdropAddress]], 'Airdropped')} className="mt-2 bg-teal-600 text-white px-4 py-2 rounded">Airdrop</button>
    </div>
  )
}
```

---

Let me know once you post the updated contract ABI or if you want a version with **dynamic metadata or a dynamic dropdown fetch** next.


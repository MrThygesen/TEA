CREATE TABLE groups (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  group_name TEXT UNIQUE NOT NULL,
  type_id INTEGER NOT NULL,
  is_active BOOLEAN DEFAULT 1
);


// File: routes/verify.js (Express backend on Render)
import express from 'express'
import { recoverAddress, hashMessage, verifyMessage } from 'ethers'

const router = express.Router()

// In-memory nonce store (can be replaced with Redis or DB)
const nonces = new Map()

// Step 1: Get nonce for a given wallet
router.get('/nonce/:wallet', (req, res) => {
  const wallet = req.params.wallet.toLowerCase()
  const nonce = Math.floor(Math.random() * 1e6).toString()
  nonces.set(wallet, nonce)
  res.json({ nonce })
})

// Step 2: Verify signature
router.post('/verify', async (req, res) => {
  const { wallet, signature } = req.body
  const nonce = nonces.get(wallet.toLowerCase())
  if (!nonce) return res.status(400).json({ error: 'Nonce not found.' })

  try {
    const message = `Sign this message to verify ownership: ${nonce}`
    const signer = verifyMessage(message, signature)

    if (signer.toLowerCase() !== wallet.toLowerCase()) {
      return res.status(401).json({ error: 'Signature mismatch' })
    }

    // OPTIONAL: Check on-chain if wallet owns specific SBT
    // const ownsSBT = await checkSBT(wallet)

    // Clean up nonce
    nonces.delete(wallet.toLowerCase())

    return res.json({ success: true, verified: true })
  } catch (err) {
    return res.status(500).json({ error: 'Verification failed', details: err.message })
  }
})

export default router
